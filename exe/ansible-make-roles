#!/usr/bin/env ruby

require 'ansible_make_role.rb'

require "indented_io"
require "shellopts"

def update_file?(src, dst)
  File.file?(dst) or return true
  File.mtime(src) > File.mtime(dst) || File.size(src) != File.size(dst)
end

def update_directory?(src, dst)
  File.directory?(dst) or return true
  result = system("diff -qr #{src} #{dst} &>/dev/null")
  raise if result.nil?
  !result
end

USAGE = "f,force r,roles-dir=DIR G,no-gitignore q,quiet v,verbose version -- MAKE-ROLES-DIRECTORY"

# TODO
#   o Replace ansible-make-role with an option:
#       -m
#         Make a single directory with a 'make.yml' file. Exclusive with -r

force = false
quiet = false
verbose = false
roles_dir = nil
gitignore = true

args = ShellOpts.process(USAGE, ARGV) { |opt, arg|
  case opt
    when '-f', '--force'; force = true
    when '-r', '--roles-dir'; roles_dir = arg
    when '-G', '--no-gitignore'; gitignore = false
    when '-q', '--quiet'; quiet = true
    when '-v', '--verbose'; verbose = true
    when '--version'; puts "#{PROGRAM} #{AnsibleMakeRole::VERSION}"; exit
  end
}

args.size <= 1 or ShellOpts.error "Illegal number of arguments"
make_roles_dir = args.first || "make-roles"
File.exist?(make_roles_dir) or ShellOpts.error "Can't find #{make_roles_dir}"
File.directory?(make_roles_dir) or ShellOpts.error "Not a directory - #{make_roles_dir}"

if roles_dir
  begin
    FileUtils.mkdir_p(roles_dir)
  rescue SystemCallError
    ShellOpts.error "Can't create directory #{roles_dir}"
  end
else
  roles_dir = "#{File.dirname(make_roles_dir)}/roles"
  File.directory?(roles_dir) or ShellOpts.error "Can't find roles directory"
end

if gitignore
  gitignore_file = "#{roles_dir}/.gitignore"
  FileUtils.touch(gitignore_file)
  gitignore_lines = IO.readlines(gitignore_file).map { |l| l.chomp }
  gitignore_dirty = false
end

Dir["#{make_roles_dir}/*.yml"].each { |src_file|
  name = File.basename(src_file, ".yml")
  src_dir = "#{make_roles_dir}/#{name}"
  dst_dir = "#{roles_dir}/#{name}"

  FileUtils.mkdir_p(dst_dir)

  puts "Making #{name}" if !quiet
  indent {
    meta_dir = "#{dst_dir}/meta"
    defaults_dir = "#{dst_dir}/defaults"
    vars_dir = "#{dst_dir}/vars"
    tasks_dir = "#{dst_dir}/tasks"
    handlers_dir = "#{dst_dir}/handlers"
    files_dir = "#{dst_dir}/files"
    templates_dir = "#{dst_dir}/templates"

    # Copy auxillary files and directories
    if File.directory?(src_dir)
      files = Dir["#{src_dir}/*"]
      dirs, files = files.partition { |f| File.directory?(f) }
      templates, files = files.partition { |f| f =~ /\.j2$/ }

      if !dirs.empty?
        first = true
        dirs.each { |src|
          dst = "#{dst_dir}/#{File.basename(src)}"
          if update_directory?(src, dst)
            puts "Copying directorie(s)" if verbose && first
            first = false
            FileUtils.cp_r(src, dst, preserve: true, remove_destination: true)
          end
        }
        puts "Directories are up to date" if verbose && first
      end
      if !files.empty?
        first = true
        FileUtils.mkdir_p(files_dir)
        files.each { |src|
          dst = "#{files_dir}/#{File.basename(src)}"
          if update_file?(src, dst)
            puts "Copying file(s)" if verbose && first
            first = false
            FileUtils.cp(src, dst, preserve: true) 
          end
        }
        puts "Files are up to date" if verbose && first
      end
      if !templates.empty?
        first = true
        FileUtils.mkdir_p(templates_dir)
        templates.each { |src|
          dst = "#{templates_dir}/#{File.basename(src)}"
          if update_file?(src, dst)
            puts "Copying template(s)" if verbose && first
            first = false
            FileUtils.cp(src, dst, preserve: true) 
          end
        }
        puts "Templates are up to date" if verbose && first
      end
    end

    AnsibleMakeRole.make(src_file, dst_dir, verbose: verbose, force: force)

    if gitignore && !gitignore_lines.include?("/#{name}")
      gitignore_lines << "/#{name}"
      gitignore_dirty = true
    end
  }
}

if gitignore && gitignore_dirty
  puts "Updating #{gitignore_file}" if !quiet
  IO.write(gitignore_file, gitignore_lines.join("\n") + "\n")
end

